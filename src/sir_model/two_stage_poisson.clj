(ns sir-model.two-stage-poisson
  (:require [anglican-code.distributions :as d]
            [sir-model.dataflow :as flow])
  (:use [anglican [core :exclude [-main]] runtime emit]))



(with-primitive-procedures
  [flow/S->]
  (defm infect
        "Infections for time t. Infecting individuals from who infect new individuals as specified by how (must be a
        function). Returns updated-coll."
        [t who whom how coll]
        (let
          [max-cases (get-in coll [t :S])
           old-cases (get-in coll [t who])

           ;; there cannot be more new cases than susceptibles
           new-cases (if (pos? old-cases)
                       (min (how old-cases) max-cases)
                       0)]
          (S-> t whom new-cases coll))))


(with-primitive-procedures
  [d/fast-poisson]
  (defm generate-poisson
        [N lambda]
        "Draws a sample from the distribution of new infections given parameter lambda and number of already
        infected individuals."
        (let [lambda* (* N lambda)]
          (if (> lambda* 30)
            (sample (fast-poisson lambda*))
            (sample (poisson lambda*))))))


(defm primary-poisson
      "Samples number of primary cases at time t from a poisson distribution. Primary cases are those that are
      generated by the already infected people, given as the value for key :I for the current timestep. Returns
      the map of compartments with updated number of primary cases for time t."
      [t lambda coll]
      (infect t :I :primary #(generate-poisson % lambda) coll))


(defm secondary-poisson
      "Samples the number of secondary cases at time t based on the number of primary cases. See primary-poisson."
      [t lambda coll]
      (infect t :primary :secondary #(generate-poisson % lambda) coll))


(defm start-poisson-poisson
      "Starts a cohort in two phases. First phase uses primary-poisson, second phase uses secondary-poisson. Is really
      just a convenience wrapper around those functions."
      [t l-1 l-2 coll]
      ((comp
         #(secondary-poisson t l-2 %)
         #(primary-poisson t l-1 %))
        coll))


(with-primitive-procedures
  [flow/update-rules flow/->compartments]
  (defm progress
        [t cases coll]

        (if (= t (count coll))
          ;; if time's up, remaining cases
          ;; are discarded
          coll

          (let
            [removed (sample (binomial cases 0.45))
             remaining (- cases removed)

             ;; update-rules returns a vector that has all
             ;; information about how coll is updated
             where-and-what (update-rules t cases removed)

             ;; in addition to removed and remaining cases,
             ;; the number of susceptibles must be retained
             ;; throughout the progression
             updated-1 (->compartments where-and-what coll)
             updated-coll (assoc-in updated-1 [t :S] (get-in updated-1 [(dec t) :S]))]

            (progress (inc t) remaining updated-coll)))))


(with-primitive-procedures
  [flow/cohort-size]
  (defm form-and-prog
        "Formation and Progression of a cohort."
        [t l-1 l-2 coll]
        ((comp
           #(progress (inc t) (cohort-size t %) %)
           #(start-poisson-poisson t l-1 l-2 %))
          coll)))




