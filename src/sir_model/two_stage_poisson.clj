(ns sir-model.two-stage-poisson
  (:require [util.functions :as u]
            [anglican-code.distributions :as d]
            [sir-model.dataflow :as flow])
  (:use [anglican [core :exclude [-main]] runtime emit]))



(with-primitive-procedures
  [flow/S->]
  (defm infect
        "Infections for time t. Infecting individuals from who infect new individuals as specified by how (must be a
        function). Returns updated-coll."
        [t who whom how coll]
        (let
          [max-cases (get-in coll [t :S])
           old-cases (get-in coll [t who])

           ;; there cannot be more new cases than susceptibles
           new-cases (if (pos? old-cases)
                       (min (how old-cases) max-cases)
                       0)]
          (S-> t whom new-cases coll))))

(with-primitive-procedures
  [d/fast-poisson]
  (defm generate-poisson
        [N lambda]
        "Draws a sample from the distribution of new infections given parameter lambda and number of already
        infected individuals."
        (let [lambda* (* N lambda)]
          (if (> lambda* 30)
            (sample (fast-poisson lambda*))
            (sample (poisson lambda*))
            ))
        ))


(defm primary-poisson
      "Samples number of primary cases at time t from a poisson distribution. Primary cases are those that are
      generated by the already infected people, given as the value for key :I for the current timestep. Returns
      the map of compartments with updated number of primary cases for time t."
      [t lambda coll]
      (infect t :I :primary #(generate-poisson % lambda) coll))


(defm secondary-poisson
      "Samples the number of secondary cases at time t based on the number of primary cases. See primary-poisson."
      [t lambda coll]
      (infect t :primary :secondary #(generate-poisson % lambda) coll))


(defm start-poisson-poisson
      "Starts a cohort in two phases. First phase uses primary-poisson, second phase uses secondary-poisson. Is really
      just a convenience wrapper around those functions."
      [t l-1 l-2 coll]
      ((comp
         #(secondary-poisson t l-2 %)
         #(primary-poisson t l-1 %))
        coll))


(with-primitive-procedures
  [flow/update-rules flow/->compartments]
  (defm progress
        [t cases coll]

        (if (= t (count coll))
          ;; if time's up, remaining cases
          ;; are discarded
          coll

          (let
            [removed (sample (binomial cases 0.45))
             remaining (- cases removed)

             ;; update-rules returns a vector that has all
             ;; information about how coll is updated
             where-and-what (update-rules t cases removed)

             ;; in addition to removed and remaining cases,
             ;; the number of susceptibles must be retained
             ;; throughout the progression
             updated-1 (->compartments where-and-what coll)
             updated-coll (assoc-in updated-1 [t :S] (get-in updated-1 [(dec t) :S]))]

            (progress (inc t) remaining updated-coll)))))


(with-primitive-procedures
  [flow/cohort-size]
  (defm form-and-prog
        "Formation and Progression of a cohort."
        [t l-1 l-2 coll]
        ((comp
           #(progress (inc t) (cohort-size t %) %)
           #(start-poisson-poisson t l-1 l-2 %))
          coll)))


(defm season-fn
      "Generic function for simulating an influenza season. Takes a starting-timestep,
      a collection of compartments and a lifetime-fn. timestep and collection are
      arguments for lifetime-fn. This of course means that lifetime-fn has to be a
      function that expects two arguments, the timestep and and collection."
      [t coll lifetime-fn]

      (let
        ;; before the actual simulation, progression for already
        ;; infected individuals at time 0 must be run once
        [initially-infected (get-in coll [0 :I])
         initial-coll (progress 1 initially-infected coll)]


        (loop [t-cur t
               coll initial-coll]

          (if (= t-cur (count coll))
            coll

            (recur (inc t-cur)
                   (lifetime-fn t-cur coll))))))


(with-primitive-procedures
  [flow/create-args-coll]
  (defquery
    two-stage-poisson-query
    [args lifetime-fn]

    (let
      [compartments (create-args-coll (:t-max args) (:compartments args) (:inits args))
       lambda-1 (sample (:prior-1 args))
       lambda-2 (sample (:prior-2 args))

       f #(lifetime-fn %1 lambda-1 lambda-2 %2)
       season (season-fn 0 compartments f)]


      {:season season})))


