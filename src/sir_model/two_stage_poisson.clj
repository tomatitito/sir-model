(ns sir-model.two-stage-poisson
  (:require [util.functions :as u]
            [sir-model.dataflow :as flow])
  (:use [anglican [core :exclude [-main]] runtime emit]))



(with-primitive-procedures
  [flow/S->]
  (defm infect
        "Infections for time t. Infecting individuals from who infect new individuals as specified by how (must be a
        function). Returns updated-coll."
        [t who whom how coll]
        (let
          [old-cases (get-in coll [t who])
           new-cases (if (pos? old-cases) (how old-cases) 0)]
          (S-> t whom new-cases coll))))


(defm generate-poisson
      [N lambda]
      "Draws a sample from the distribution of new infections given parameter lambda and number of already
      infected individuals."
      (sample (poisson (* N lambda))))


(defm primary-poisson
      "Samples number of primary cases at time t from a poisson distribution. Primary cases are those that are
      generated by the already infected people, given as the value for key :I for the current timestep. Returns
      the map of compartments with updated number of primary cases for time t."
      [t lambda coll]
      (infect t :I :primary #(generate-poisson % lambda) coll))


(defm secondary-poisson
      "Samples the number of secondary cases at time t based on the number of primary cases. See primary-poisson."
      [t lambda coll]
      (infect t :primary :secondary #(generate-poisson % lambda) coll))


(defm start-poisson-poisson
      "Starts a cohort in two phases. First phase uses primary-poisson, second phase uses secondary-poisson. Is really
      just a convenience wrapper around those functions."
      [t l-1 l-2 coll]
      ((comp
         #(secondary-poisson t l-2 %)
         #(primary-poisson t l-1 %))
        coll))


(with-primitive-procedures
  [flow/update-rules flow/->compartments]
  (defm progress
        [t cases coll]

        (if (= t (count coll))
          ;; if time's up, remaining cases
          ;; are discarded
          coll

          (let
            [removed (sample (binomial cases 0.5))
             remaining (- cases removed)

             ;; update-rules returns a vector that has all
             ;; information about how coll is updated
             where-and-what (update-rules t cases removed)

             ;; in addition to removed and remaining cases,
             ;; the number of susceptibles must be retained
             ;; throughout the progression
             updated-1 (->compartments where-and-what coll)
             updated-coll (assoc-in updated-1 [t :S] (get-in updated-1 [(dec t) :S]))]

            (progress (inc t) remaining updated-coll)))))


(with-primitive-procedures
  [flow/cohort-size]
  (defm form-and-prog
        [t l-1 l-2 coll]
        ((comp
           #(progress (inc t) (cohort-size t %) %)
           #(start-poisson-poisson t l-1 l-2 %))
          coll)))


(defm season-fn
      "Generic function for simulating an influenza season. Takes a starting-timestep,
      a lifetime-fn and a collection of compartments. lifetime-fn has to be a function
      that expects two arguments, the timestep and and collection."
      [t coll lifetime-fn]
      (let
        ;; before the actual simulation, progression for already
        ;; infected individuals at time 0 must be run once
        [initially-infected (get-in coll [0 :I])
            initial-coll (progress 1 initially-infected coll)]
        (loop [t-cur t
               coll initial-coll]

          (if (= t-cur (count coll))
            coll

            (recur (inc t-cur)
                   (lifetime-fn t-cur coll))))))


(with-primitive-procedures
  [flow/create-args-coll]
  (defquery
    dancing-query
    [args lifetime-fn]

    (let
      [compartments (create-args-coll (:t-max args) (:compartments args) (:inits args))
       lambda-1 (sample (:prior-1 args))
       lambda-2 (sample (:prior-2 args))

       ;season-fn (fn [t r-1 r-2 coll]
       ;            (loop [t-cur t
       ;                   coll coll]
       ;              (if (= t-cur (count coll))
       ;                coll
       ;                (recur (inc t-cur)
       ;                       (lifetime-fn t-cur r-1 r-2 coll))))
       ;            )

       ;ans (season-fn 0 lambda-1 lambda-2 compartments)
       f #(lifetime-fn %1 lambda-1 lambda-2 %2)
       ans (season-fn 0 compartments f)

       ]

      {:ans ans})))


(def arg-map
  {:t-max        30
   :compartments [:S :I :R :primary :secondary]
   :inits        {:S 10000 :I 1000}
   :prior-1      (uniform-continuous 0.2 0.4)
   :prior-2      (uniform-continuous 0.3 0.5)
   :params       [1 2]
   :data         [2 1 0 3]}
  )





(def samples (doquery :lmh dancing-query [arg-map form-and-prog]))
(first samples)
(u/from-result (first samples) [:new 0 :S])

(defn posterior
  ([args n thin]
   (as-> args m
         (doquery :smc dancing-query [m] :number-of-particles 1000)
        (take n m)
      (take-nth thin m)))
  ([args n]
    (posterior args n 1)))
