(ns sir-model.dancingqueen
  (:require [util.functions :as u])
  (:use [anglican [core :exclude [-main]] runtime emit]))


(defn create-args-coll
  "Returns a datastructure holding the compartments for n timesteps. Takes an int, a vector of keywords
  and optionally a map of key value pairs. Returns a vector of n maps, where each map has all the the
  keywords in keys with inital value of zero. If inits is supplied, the first entry in the returned vector
  will associate the given values to the corresponding keys.

      (create-args-coll 10 [:S :I :R] {:S 10000 :I 100})"
  ([n keys]
   (let [m (zipmap keys (repeat (count keys) 0))]
     (into [] (repeat n m))))
  ([n keys inits]
    (let [tail (create-args-coll (dec n) keys)
          head (reduce #(assoc-in %1 [(key %2)] (val %2)) (first tail) inits)]
      (into [head] tail))))


(defn a->b
  "Takes a map m and two vectors a and b with keys, substracts value from a and adds it to b."
  [a b value m]
  (-> m
      (update-in ,,, a #(- % value))
      (update-in ,,, b #(+ % value))))


(defn S->
  "Takes a map of compartments, subtracts value from :S at time t and adds it to to at time t."
  [t to value coll]
  (a->b [t :S] [t to] value coll))


(defn S->primary [t value coll]
  (a->b [t :S] [t :primary] value coll))


(defn S->secondary [t value coll]
  (a->b [t :S] [t :secondary] value coll))


(defn ->coll
  "Adds value to compartments coll. target is a keyseq for determining where to add value."
  [target value coll]
    (update-in coll target + value))


(defn ->compartments
  "Adds multiple values to corresponding compartments. args needs to be a sequence of vector
  nested keys and corresponding values. Returns updated coll with each value added to the
  corresponding compartment."
  [targets-and-vals coll]
  (let [pairs (partition 2 targets-and-vals)]
    (reduce #(->coll (first %2) (second %2) %1) coll pairs)))


(defn ->I [t value coll]
  (->coll [t :I] value coll))


(defn ->R [t value coll]
  (->coll [t :R] value coll))


(defn update-rules
  "Given the number of cases and the number of removed individuals, determines how the compartments need to be updated.
  Returns a vector of (nested) keyseqs and corresponding values, which is fed into ->compartments."
  [t cases removed]
  [[t :R] removed [t :I] (- cases removed)])


(with-primitive-procedures
  [S->]
  (defm infect
        "Infections for time t. Infecting individuals from who infect new individuals as specified by how (must be a
        function). Returns updated-coll."
        [t who whom how coll]
        (let
          [old-cases (get-in coll [t who])
           new-cases (if (pos? old-cases) (how old-cases) 0)]
          (S-> t whom new-cases coll))))


(defm generate-poisson
      [N lambda]
      "Draws a sample from the distribution of new infections given parameter lambda and number of already
      infected individuals."
      (sample (poisson (* N lambda))))


(with-primitive-procedures
  [S->primary]
  (defm primary-poisson
        "Samples number of primary cases at time t from a poisson distribution. Primary cases are those that are
        generated by the already infected people, given as the value for key :I for the current timestep. Returns
        the map of compartments with updated number of primary cases for time t."
        [t lambda coll]
        (infect t :I :primary #(generate-poisson % lambda) coll)))


(with-primitive-procedures
  [S->secondary]
  (defm secondary-poisson
        "Samples the number of secondary cases at time t based on the number of primary cases. See primary-poisson."
        [t lambda coll]
        (infect t :primary :secondary #(generate-poisson % lambda) coll)))


(defm start-poisson-poisson
      "Starts a cohort in two phases. First phase uses primary-poisson, second phase uses secondary-poisson. Is really
      just a convenience wrapper around those functions."
      [t l-1 l-2 coll]
      ((comp
         #(secondary-poisson t l-2 %)
         #(primary-poisson t l-1 %))
        coll))


(defn cohort-size
  "Number of individuals for cohort starting from time t."
  [t coll]
  (+
    (get-in coll [t :primary])
    (get-in coll [t :secondary])))


(with-primitive-procedures
  [update-rules ->compartments]
  (defm progress
        [t cases coll]

        (if (= t (count coll))
          ;; if time's up, eventually remaining cases
          ;; are discarded
          coll

          (let
            [removed (sample (binomial cases 0.5))
             remaining (- cases removed)

             where-and-what (update-rules t cases removed)

             ;; in addition to removed and remaining cases,
             ;; the number of susceptibles must be retained
             ;; throughout the progression
             updated-1 (->compartments where-and-what coll)
             updated-coll (assoc-in updated-1 [t :S] (get-in updated-1 [(dec t) :S]) )
             ]

            (progress (inc t) remaining updated-coll)))))


(with-primitive-procedures
  [cohort-size]
  (defm form-and-prog
        [t l-1 l-2 coll]
        ((comp
           #(progress (inc t) (cohort-size t %) %)
           #(start-poisson-poisson t l-1 l-2 %))
          coll)))


(with-primitive-procedures
  [create-args-coll]
  (defquery
    dancing-query
    [args lifetime-fn]

    (let
      [compartments (create-args-coll (:t-max args) (:compartments args) (:inits args))
       lambda-1 (sample (:prior-1 args))
       lambda-2 (sample (:prior-2 args))

       season-fn (fn [t r-1 r-2 coll]
                   (loop [t-cur t
                          coll coll]
                     (if (= t-cur (count coll))
                       coll
                       (recur (inc t-cur)
                              (lifetime-fn t-cur r-1 r-2 coll))))
                   )

       ans (season-fn 0 lambda-1 lambda-2 compartments)

       ]

      {:ans ans})))


(def arg-map
  {:t-max        30
   :compartments [:S :I :R :primary :secondary]
   :inits        {:S 10000 :I 1000}
   :prior-1      (uniform-continuous 0.2 0.4)
   :prior-2      (uniform-continuous 0.3 0.5)
   :params       [1 2]
   :data         [2 1 0 3]}
  )





(def samples (doquery :lmh dancing-query [arg-map form-and-prog]))
(first samples)
(u/from-result (first samples) [:new 0 :S])

(defn posterior
  ([args n thin]
   (as-> args m
         (doquery :smc dancing-query [m] :number-of-particles 1000)
        (take n m)
      (take-nth thin m)))
  ([args n]
    (posterior args n 1)))
