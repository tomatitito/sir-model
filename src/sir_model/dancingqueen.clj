(ns sir-model.dancingqueen
  (:require [util.functions :as u])
  (:use [anglican [core :exclude [-main]] runtime emit]))


(defn create-args-coll
  "Returns a datastructure holding the compartments for n timesteps. Takes an int, a vector of keywords
  and optionally a map of key value pairs. Returns a vector of n maps, where each map has all the the
  keywords in keys with inital value of zero. If inits is supplied, the first entry in the returned vector
  will associate the given values to the corresponding keys.

      (create-args-coll 10 [:S :I :R] {:S 10000 :I 100})"
  ([n keys]
   (let [m (zipmap keys (repeat (count keys) 0))]
     (into [] (repeat n m))))
  ([n keys inits]
    (let [tail (create-args-coll (dec n) keys)
          head (reduce #(assoc-in %1 [(key %2)] (val %2)) (first tail) inits)]
      (into [head] tail))))


(defn a->b
  "Takes a map m and two vectors a and b with keys, substracts value from a and adds it to b."
  [a b value m]
  (-> m
      (update-in ,,, a #(- % value))
      (update-in ,,, b #(+ % value))))


(defn S->
  "Takes a map of compartments, subtracts value from :S at time t and adds it to to at time t."
  [t to value coll]
  (a->b [t :S] [t to] value coll))


(defn S->primary [t value coll]
  (a->b [t :S] [t :primary] value coll))


(defn S->secondary [t value coll]
  (a->b [t :S] [t :secondary] value coll))


(with-primitive-procedures
  [S->]
  (defm infect
        "Infections for time t. Infecting individuals from who infect new individuals as specified by how (must be a
        function). Returns updated-coll."
        [t who whom how coll]
        (let
          [old-cases (get-in coll [t who])
           new-cases (if (pos? old-cases) (how old-cases) 0)]
          (S-> t whom new-cases coll))))


(defm generate-poisson
      [N lambda]
      "Draws a sample from the distribution of new infections given parameter lambda and number of already
      infected individuals."
      (sample (poisson (* N lambda))))


(with-primitive-procedures
  [S->primary]
  (defm primary-poisson
        "Samples number of primary cases at time t from a poisson distribution. Primary cases are those that are
        generated by the already infected people, given as the value for key :I for the current timestep. Returns
        the map of compartments with updated number of primary cases for time t."
        [t lambda coll]
        (infect t :I :primary #(generate-poisson % lambda) coll)))


(with-primitive-procedures
  [S->secondary]
  (defm secondary-poisson
        "Samples the number of secondary cases at time t based on the number of primary cases. See primary-poisson."
        [t lambda coll]
        (infect t :primary :secondary #(generate-poisson % lambda) coll)))


(defm start-poisson-poisson
      "Starts a cohort in two phases. First phase uses primary-poisson, second phase uses secondary-poisson. Is really
      just a convenience wrapper around those functions."
      [t l-1 l-2 coll]
      ((comp
         #(secondary-poisson t l-2 %)
         #(primary-poisson t l-1 %)
         )
        coll))


(with-primitive-procedures
  [create-args-coll S->]
  (defquery
    dancing-query
    [args]

    (let
      [compartments (create-args-coll (:t-max args) (:compartments args) (:inits args))
       lambda-1 (sample (:prior-1 args))

       ;ans (primary-poisson 0 lambda-1 compartments)
       ans (start-poisson-poisson 0 0.2 0.4 compartments)
       ]

      {:ans ans})))


(def arg-map
  {:t-max        10
   :compartments [:S :I :R :primary :secondary]
   :inits        {:S 1000 :I 10}
   :prior-1      (uniform-continuous 0.2 0.5)
   :params       [1 2]
   :data         [2 1 0 3]}
  )





(def samples (doquery :lmh dancing-query [arg-map]))
(first samples)
(u/from-result (first samples) [:new 0 :S])

(defn posterior
  ([args n thin]
   (as-> args m
         (doquery :smc dancing-query [m] :number-of-particles 1000)
        (take n m)
      (take-nth thin m)))
  ([args n]
    (posterior args n 1)))

;(def comp-map (create-args-coll 10 [:S :I :R :primary :secondary] {:S 1000 :I 10}))
;comp-map
;
;(def samples (posterior comp-map 5))
;samples
;(util.functions/from-results samples [:new])

